PROGRAM ::= {CLASS | METHOD}
ACCESS SPEC ::= private | protected | public
ADDOP ::= + | -
ALLOCATOR ::= new TYPE ID (ARGLIST)
ALLOCATOR ::= new TYPE ID[EXPR]
ARGLIST ::= EXPR {, EXPR } |e
ASSIGNSTMT ::= FACTOR = EXPR
BEXPR ::= SIMPLEEXPR
BEXPR ::= SIMPLEEXPR1 RELOP SIMPLEEXPR2
BLOCK ::= VARDECS begin STMTLIST end
BODY ::= SUPER INIT THIS INIT BLOCK
CALLSTMT ::= call FACTOR
CAST EXPR ::= cast (TYPE ID, EXPR)
CATCH CLAUSE ::= catch ( TYPE ID id) STMTLIST
CEXPR ::= BEXPR { and BEXPR }
CLASS ::= class id1 SUPER CLASS is { CLASS MEMBER } end id2
CLASS MEMBER ::= FIELD DECL
CLASS MEMBER ::= METHOD DECL
ELSEPART ::= e | else STMTLIST
EXPR ::= CEXPR { or CEXPR }
FACTOR1 ::= - FACTOR2
FACTOR1 ::= not FACTOR2
FACTOR ::= number
FACTOR ::= false
FACTOR ::= true
FACTOR ::= null
FACTOR ::= ALLOCATOR
FACTOR ::= CAST EXPR
FACTOR ::= VALUE OR REF { MEMBER PART }
FIELD DECL ::= ACCESS SPEC TYPE id { , id };
IFSTMT ::= if EXPR then STMTLIST
		   {elsif EXPR then STMTLIST}
		   ELSEPART
		   end if
INPUTSTMT ::= input >> FACTOR
LOOPSTMT ::= loop STMTLIST end loop
MEMBER PART ::= .id
MEMBER PART ::= .id(ARGLIST)
MEMBER PART ::= .id[EXPR]
METHOD ::= method M TYPE METHOD ID (PARAMETERS ) is BODY id
METHOD DECL ::= ACCESS SPEC method M TYPE id (PARAMETER DECL );
METHOD ID ::= id :: id | id
M TYPE ::= TYPE | void
MULTOP ::= * | / | mod
OPTIONAL ID ::= id |e
OPTIONAL TYPE ID ::= id |e
OUPUTSTMT ::= output << EXPR
OUTPUTSTMT ::= output << string
PARAMETER DECL ::= TYPE OPTIONAL ID {, TYPE OPTIONAL ID } | e
PARAMETERS ::= TYPE id {, TYPE id} | e
RELOP ::= == | < | <= | > | >= | #
SIMPLEEXPR ::= TERM { ADDOP TERM }
STMT ::= BLOCK | TRYSTMT
STMT ::= IFSTMT | LOOPSTMT | ASSIGNSTMT
STMT ::= CALLSTMT | OUTPUTSTMT | INPUTSTMT
STMT ::= continue | break
STMT ::= return | return EXPR |
STMT ::= exit
STMT ::= throw EXPR
STMTLIST ::= { STMT; }
SUPER INIT ::= super(ARGLIST); | e
SUPER CLASS ::= extends id | e
TERM ::= FACTOR {MULTOP FACTOR }
THIS INIT ::= this(ARGLIST); | e
TRYSTMT ::= try STMTLIST CATCH CLAUSE { CATCH CLAUSE } end try
TYPE ::= TYPE ID | TYPE ID [ ]
TYPE ID ::= integer | boolean | id
VALUE OR REF ::= this
VALUE OR REF ::= super
VALUE OR REF ::= id
VALUE OR REF ::= id[EXPR]
VALUE OR REF ::= id(ARGLIST)
VALUE OR REF ::= (EXPR)
VARDECLIST ::= TYPE id {, id };
VARDECS ::= declare VARDECLIST { VARDECLIST } | e